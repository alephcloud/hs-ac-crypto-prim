-- ------------------------------------------------------ --
-- Copyright © 2014 AlephCloud Systems, Inc.
-- ------------------------------------------------------ --

{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
module TWC.Crypto.Ecc.OpenSSL
(
-- * Elliptic Curve Mathemtics
  EcCurve
, curve
, curveG
, curveR
, curveP
, curveB
, curveFieldLength
, CurveFieldLength
, EcFieldLength
, ecFieldLength

-- * EcPoint
, EcPoint
, ecPoint
, ecX
, ecY
, ecPointMul
, ecPointMul2
, ecPointAdd
, ecIdentity
, ecIsIdentity

-- * Scalar Values of the cyclic subgroup generated by 'curveG' of order 'curveR'
, EcScalar
, ecScalarBn
, ecScalar
, ecScalarDiv
) where

import TWC.Crypto.ByteArrayL
import TWC.Crypto.Ecc.OpenSSLBind
import TWC.Crypto.Bn

newtype EcPoint = EcPoint Point

type EcCurve = Group

instance Eq EcPoint where
    (EcPoint a) == (EcPoint b) = pointEq curve a b

curve ∷ EcCurve
curve = maybe (error "cannot get openssl curve p521") id
      $ groupFromCurveName
      $ maybe (error "cannot convert text to nid") id
      $ txt2Nid "1.3.132.0.35"

curveP ∷ Bn
curveP = let (p,_,_) = groupGetCurveGFp curve in p

curveA ∷ Bn
curveA = let (_,a,_) = groupGetCurveGFp curve in a

curveB ∷ Bn
curveB = let (_,_,b) = groupGetCurveGFp curve in b

curveG ∷ EcPoint
curveG = EcPoint $ groupGetGenerator curve

curveR ∷ Bn
curveR = groupGetOrder curve

-- FIXME
type CurveFieldLength = N66
type EcFieldLength = CurveFieldLength

curveFieldLength ∷ Int
curveFieldLength = bnLength curveR

ecFieldLength ∷ Int
ecFieldLength = curveFieldLength

newtype EcScalar = EcScalar { ecScalarBn ∷ Bn }
    deriving (Eq, Ord, Show, Integral, Real, Enum)

ecScalar ∷ Bn → EcScalar
ecScalar i = EcScalar (i `mod` curveR)

ecScalarDiv ∷ Bn → Bn → Bn
ecScalarDiv a b = (a * bnInverseMod b curveP) `mod` curveP

instance Num EcScalar where
    (EcScalar a) + (EcScalar b) = EcScalar $ (a + b) `mod` curveR
    (EcScalar a) - (EcScalar b) = EcScalar $ (a - b) `mod` curveR
    (EcScalar a) * (EcScalar b) = EcScalar $ (a * b) `mod` curveR
    abs = id
    signum a = if a == 0 then 0 else 1
    fromInteger = ecScalar . fromInteger

ecX ∷ EcPoint → Bn
ecX (EcPoint p) = fst $ pointToAffineGFp curve p

ecY ∷ EcPoint → Bn
ecY (EcPoint p) = snd $ pointToAffineGFp curve p

ecIdentity ∷ EcPoint
ecIdentity = EcPoint $ pointInfinity curve

ecIsIdentity ∷ EcPoint → Bool
ecIsIdentity (EcPoint p) = pointIsAtInfinity curve p

ecPoint ∷ Bn → Bn → EcPoint
ecPoint x y = EcPoint $ pointFromAffineGFp curve (x,y)

-- | b.a
--
-- FIXME reorder arguments
--
ecPointMul ∷ EcPoint → EcScalar → EcPoint
ecPointMul (EcPoint a) (EcScalar b) = EcPoint $ pointMul curve a b

ecPointDouble ∷ EcPoint → EcPoint
ecPointDouble (EcPoint a) = EcPoint $ pointDbl curve a

-- | b.a + c.d
--
-- FIXME reorder arguments
-- VH: probably can use something faster in the binding
ecPointMul2 ∷ EcPoint → EcScalar → EcScalar → EcPoint → EcPoint
ecPointMul2 a b c d
    | ecIsIdentity a || b == 0 = d `ecPointMul` c
    | ecIsIdentity d || c == 0 = a `ecPointMul` b
    | otherwise                = ecPointMul a b `ecPointAdd` ecPointMul d c

ecPointAdd ∷ EcPoint → EcPoint → EcPoint
ecPointAdd (EcPoint a) (EcPoint b) = EcPoint $ pointAdd curve a b
